// SPDX-License-Identifier: GPL-2.0-only
//! Kernel bindings for boxfs
//!
//! These are the C functions we can call from Rust.
//! In a real kernel build, these would be generated by bindgen.

use core::ffi::c_void;

/// Box filesystem magic number
pub const BOXFS_MAGIC: u32 = 0x424F5846; // "BOXF"

/// GFP_KERNEL allocation flag
pub const GFP_KERNEL: u32 = 0x400CC0; // Approximate value

/// File types for dir_emit
pub const DT_UNKNOWN: u8 = 0;
pub const DT_REG: u8 = 8;
pub const DT_DIR: u8 = 4;
pub const DT_LNK: u8 = 10;

// Opaque kernel types
#[repr(C)]
pub struct SuperBlock {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct BlockDevice {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct BufferHead {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct DirContext {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct BoxfsSbInfo {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct KStatfs {
    pub f_type: i64,
    pub f_bsize: i64,
    pub f_blocks: u64,
    pub f_bfree: u64,
    pub f_bavail: u64,
    pub f_files: u64,
    pub f_ffree: u64,
    pub f_fsid: [i32; 2],
    pub f_namelen: i64,
    pub f_frsize: i64,
    pub f_flags: i64,
    pub f_spare: [i64; 4],
}

// External C functions (defined in rust_helpers.c)
extern "C" {
    // Buffer head operations
    pub fn boxfs_sb_bread(sb: *mut SuperBlock, block: u64) -> *mut BufferHead;
    pub fn boxfs_sb_bread_unmovable(sb: *mut SuperBlock, block: u64) -> *mut BufferHead;
    pub fn boxfs_brelse(bh: *mut BufferHead);
    pub fn boxfs_put_bh(bh: *mut BufferHead);
    pub fn boxfs_bh_data(bh: *mut BufferHead) -> *mut c_void;
    pub fn boxfs_bh_size(bh: *mut BufferHead) -> usize;

    // Superblock info accessors
    pub fn boxfs_get_sb_info(sb: *mut SuperBlock) -> *mut BoxfsSbInfo;
    pub fn boxfs_set_metadata(sb: *mut SuperBlock, metadata: *mut c_void);
    pub fn boxfs_get_metadata(sb: *mut SuperBlock) -> *mut c_void;
    pub fn boxfs_set_archive_size(sb: *mut SuperBlock, size: u64);
    pub fn boxfs_set_trailer_offset(sb: *mut SuperBlock, offset: u64);
    pub fn boxfs_set_root_ino(sb: *mut SuperBlock, ino: u64);
    pub fn boxfs_get_root_ino(sb: *mut SuperBlock) -> u64;

    // Block device access
    pub fn boxfs_sb_bdev(sb: *mut SuperBlock) -> *mut BlockDevice;
    pub fn boxfs_sb_blocksize(sb: *mut SuperBlock) -> u32;
    pub fn boxfs_sb_blocksize_bits(sb: *mut SuperBlock) -> u8;
    pub fn boxfs_bdev_nr_bytes(bdev: *mut BlockDevice) -> i64;

    // Directory emission
    pub fn boxfs_dir_emit(
        ctx: *mut DirContext,
        name: *const u8,
        namelen: i32,
        ino: u64,
        dtype: u32,
    ) -> bool;
    pub fn boxfs_dir_emit_dot(file: *mut c_void, ctx: *mut DirContext) -> bool;
    pub fn boxfs_dir_emit_dotdot(file: *mut c_void, ctx: *mut DirContext) -> bool;
    pub fn boxfs_dir_ctx_pos(ctx: *mut DirContext) -> i64;
    pub fn boxfs_dir_ctx_set_pos(ctx: *mut DirContext, pos: i64);

    // Memory allocation
    pub fn boxfs_kmalloc(size: usize, flags: u32) -> *mut c_void;
    pub fn boxfs_kzalloc(size: usize, flags: u32) -> *mut c_void;
    pub fn boxfs_kfree(ptr: *mut c_void);

    // Printk
    pub fn boxfs_pr_info(msg: *const u8);
    pub fn boxfs_pr_err(msg: *const u8);
    pub fn boxfs_pr_warn(msg: *const u8);
    pub fn boxfs_pr_debug(msg: *const u8);

    // Zstd decompression
    pub fn boxfs_zstd_decompress(
        src: *const c_void,
        src_len: usize,
        dst: *mut c_void,
        dst_len: usize,
        out_len: *mut usize,
    ) -> i32;

    // XZ decompression
    pub fn boxfs_xz_decompress(
        src: *const c_void,
        src_len: usize,
        dst: *mut c_void,
        dst_len: usize,
        out_len: *mut usize,
    ) -> i32;

    // Readahead helpers
    pub fn boxfs_readahead_pos(ractl: *mut ReadaheadControl) -> i64;
    pub fn boxfs_readahead_length(ractl: *mut ReadaheadControl) -> usize;
    pub fn boxfs_readahead_folio(ractl: *mut ReadaheadControl) -> *mut Folio;
    pub fn boxfs_folio_pos(folio: *mut Folio) -> i64;
    pub fn boxfs_folio_size(folio: *mut Folio) -> usize;
    pub fn boxfs_kmap_local_folio(folio: *mut Folio, offset: usize) -> *mut c_void;
    pub fn boxfs_kunmap_local(addr: *mut c_void);
    pub fn boxfs_folio_mark_uptodate(folio: *mut Folio);
    pub fn boxfs_folio_unlock(folio: *mut Folio);
    pub fn boxfs_folio_zero_segment(folio: *mut Folio, start: usize, end: usize);
}

// Opaque kernel types for readahead
#[repr(C)]
pub struct ReadaheadControl {
    _opaque: [u8; 0],
}

#[repr(C)]
pub struct Folio {
    _opaque: [u8; 0],
}

/// Read a block from the block device.
///
/// Returns a slice of the block data, or None if the read failed.
/// The caller must call `release_block` when done with the data.
pub unsafe fn read_block(sb: *mut SuperBlock, block: u64) -> Option<(*mut BufferHead, &'static [u8])> {
    let bh = boxfs_sb_bread(sb, block);
    if bh.is_null() {
        return None;
    }

    let data = boxfs_bh_data(bh) as *const u8;
    let size = boxfs_bh_size(bh);
    let slice = core::slice::from_raw_parts(data, size);

    Some((bh, slice))
}

/// Release a block previously read with `read_block`.
pub unsafe fn release_block(bh: *mut BufferHead) {
    boxfs_brelse(bh);
}
